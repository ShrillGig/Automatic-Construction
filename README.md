cv2.getOptimalNewCameraMatrix(mtx, dist, (w, h), 1, (w,h))

mtx - интрисивные параметры камеры на исходных изображениях с дисторсией
dist - параметры дисторсии камеры
w, h - ширина и высота камеры (первая скобка)
w. h -  ширина и высота камеры (вторая скобка)

cv2.undistort(img, mtx, dist, None, newK)

img - изображение, которое нужно избавить от дисторсии
mtx -  интрисивные параметры камеры на исходных изображениях с дисторсией
dist - параметры дисторсии камеры
newK - новая интрисивная матрица уже без искажений

cv2.goodFeaturestoTrack(gray, max_corners, quality, min_dist)

gray - изображение, на котором нужно найти эти самые углы
max_corners - максимально количество углов, которое может быть найдено
quality - качество резкости найденных углов в диапазоне [0,1]. Чем ближе к 1, тем строже отбор
min_dist - пары точек, стоящий ближе этого значения в пикселях, удаляется самая слабая из них двоих

cv2.circle(img, (x, y), radius, color)

img - изображение, на котором хотите отметить кружки
x, y - координаты, по которым будет установлен кружок
radius - радиус установленного кружка
color - цвет установленного кружка


Этапы получения мировых координаты углов обьекта следующие:

1. Получение координат углов относительно изображения
-получаем углы с помощью cv2.goodFeaturesToTrack()
-отмечаем их на изображении для наглядности с помощью cv2.circle()

2. Получение коордиенат углов обьекта относительно камеры
-переводим координаты относительно изображения в координаты относительно камеры с помощью
обратных формул.

3. Получение мировых координат углов обьекта
-применяем обратное экстрезивное преобразование.

4. Дополнительные преобразования
-изабвляемся от отрицательных координат
-переводим все координаты в int

Как передаются координаты на Ардуино

-берем строку из x, y координат
-с помощью функции zip() получаем и ключ и значение
- собираем строку из ключа и значения
- кодируем строку в UTF-8 и отправляем на ардуино
- ждем ответ от Ардуино и дешифруем его
- отправляем в терминале результат работы


